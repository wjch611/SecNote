[TOC]



##### GET请求和POST请求共存情况：

```
这是 HTTP 协议规范允许的行为，不冲突。其实：

一个请求同时可以有 GET 参数（在 URL 里）和 POST 参数（在 body 里）

它们分别属于不同的部分：

?xxx=yyy → 是 URL 的 查询参数（query string），本质是 GET 参数；

而 POST 请求体（body）中还可以单独再传 POST 数据，比如 form-data 或 json。
```

##### 路由访问：

有时访问源码目录下存在的文件访问不了，可能是路由配置导致

**站库分离：**

1. 其他服务器上的数据库
2. 云数据库

**前后端分离：**

前端使用JS框架/框架库开发（VUE、JQuery库...）、前后端使用API传输数据

特点：

1. 后台可能在不同域名
2. 前端界面简洁
3. 前端漏洞少
4. API数据传输效率小于传统

对渗透的影响：

```
 1. 前端使用框架、漏洞减少
 1. 前后端使用API传输，API安全风险上升
 1. 前后端分离导致的CORS
```

**软件继承安装者权限**

**镜像网站：**

1. 搭建：直接拉取镜像，run就可以了

**分配站：**

1. 主域名是建站平台的

**WAF：**

1. 阻碍常规WEB渗透手段/后门
2. 常见免费WAF：D盾

**正/反向代理：**

需要代理都是解决直接访问不到的问题

1. 正：A访问不了C，B可以访问C，A借助B与C进行数据通讯（A本机、C目标服务器、代理服务器）
2. 反：客户端直接访问不了服务端A但是可以访问到服务端B，服务端A反向代理为服务端B，客户端访问A = 访问B
   1. 反向代理对渗透测试的影响：比如[www.a.com](www.a.com)设置反向代理为[www.b.com](www.b.com)，那么当浏览器访问a.com就会跳到b.com去（有点像**URL跳转**）

**负载均衡：**

一个网站/域名对应多个服务器，其中一个服务器坏了也不影响网站运行

**APP**：

1. 封装开发
2. 原生开发
3. H5+VUE

**小程序**：

1. 封装开发
2. H5+VUE

**封装开发：**

特点：web源码是支持页面转换的

封装：网站地址直接去一站封装网站

其实就是一个网站！

测试思路：常规web渗透思路

**原生开发：**

安卓一般使用JAVA

测试思路：

1. 需要反编译、看懂走什么协议
2. 抓包

**APP逆向/APP渗透测试区别**：

1. 渗透是去里面寻找资产
2. 逆向是从APP代码本身去寻找漏洞

**反弹Shell:**

通过命令/脚本语言获取对方的shell

1. 正向连接：自己主动根据ip端口去连接，对方设置监听这个端口
2. 反向连接：对方主动将控制传给给自己，自己设置监听这个端口

生成工具：

[反弹shell生成器](https://forum.ywhack.com/reverse-shell/)

**正/反连接场景：**

1. 内-外网：当外网的机器想要反弹内网的shell，需要使用反向连接，因为正向找不到内网的ip
2. 防火墙策略：当目标服务器防火墙设置不允许入站，那么需要反向连接

**反弹shell使用场景：**

可以命令执行

1. 但是需要进一步输入，不然就卡住了
2. 输出无回显

**数据外带：**

解决可以命令执行，但是输出无回显

ping命令结合管道符、dnslog网站、powershell..

**抓不到某些程序的包：**

比如腾讯文档一些大型程序，因为设置权限很高

**抓包：**

1. 对象
2. 协议
3. 反抓

**封包技术与安全测试：**

封包是什么协议都能抓，只能抓模拟器APP，主要用于游戏外挂

对于安全测试，用于**获取远端服务器的ip地址**

**逆向加固：**

防止反编译

**加密/编码：**

1. base64是编码，可解码
2. 单项散列加密：只可碰撞，不可解密，md5加密，没有大写字母
3. aes/des加密，对称加密，与base64区别在存在"/"，"+"
4. 非对称：DSA、RSA

**前端/后端加密:**

加密逻辑可能存在JS代码中也可能存在后端代码中，后端代码不可见

**状态码：**

1. 200文件存在
2. 404文件不存在
3. 403**文件夹存在**
4. 5xx/3xx，可能存在
5. 401未授权

**POSTMAN：**

构造发包工具，API测试

##### http包结构：

请求：

1. 请求行

   ```
   GET /index.html HTTP/1.1
   ```

2. 请求头

   ```
   Host: example.com
   User-Agent: Mozilla/5.0
   Cookie: session=abc123
   Content-Type: application/json
   ```

3. 请求体（下面是json类型的，类型要看content-type)

   ```
   {
     "username": "admin",
     "password": "123456"
   }
   ```

响应：

1. 状态行

   ```
   HTTP/1.1 200 OK
   ```

2. 响应头

   ```
   Content-Type: text/html; charset=UTF-8
   Content-Length: 1024
   Set-Cookie: token=xyz789
   ```

3. 响应体（同理，也要看content-type)

   ```
   <html>
     <body>Hello World!</body>
   </html>
   ```

##### 网站搭建好了，没有文件在目录，访问显示：forbidden

##### session:

1. session是sessionid保留在cookie中，但是凭据是保留在服务端sessionid对应的文件中
2. sessionid一段时间没有访问之后，服务端对应文件会自动删除
3. sessionid每次访问就会产生一个新的，但是对应文件内容为空，登录成功后才会保留凭据
4. 一般token也会存在于sessionid对应文件中

##### 决定文件是下载还是读取取决于响应给浏览器的响应头：

下载响应头：

```
header('Content-Disposition: attachment; filename="' . basename($file) . '"');
header('Content-Length: ' . filesize($file));
header('Cache-Control: must-revalidate');
```

##### 代码执行与命令执行

1. 代码执行是指能控制执行代码
2. 代码执行->命令执行
3. 命令执行推不到代码执行

##### git clone https://github.com/top-think/think tp5：

从 GitHub 克隆 ThinkPHP 5.x 版本的代码到本地，并命名为 `tp5` 文件夹。
