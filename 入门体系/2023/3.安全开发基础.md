[TOC]

### 一、PHP

1. php文件中可能存在html，但是前端只显示html和php的执行结果
2. php文件中执行js代码，echo js代码到浏览器执行
3. html的**action**属性指定数据处理文件，**空/#**，指**当前文件**中的代码
4. php,header跳转函数
5. 登入设置cookie，登出删除cookie
6. token，**保证数据包的唯一性**，比如可以防止暴力破解，token是每发一次数据包就会生成一次的随机数，这个随机数是访问网站执行脚本产生的
7. session与cookie
   1. cookie存与浏览器，值是用户名密码等参数，存活时间长
   2. session也存与浏览器，但是内容是服务端的一个文件名=sessionid，这个文件中存着用户名密码等信息，这个id存活时间短，关闭浏览器/一段时间后未操作，服务端就会删除这个文件
   
   **sessionid一般存在与cookie中**
8. 文件上传判断：
   1. 黑/白名单过滤
   2. 后缀/类型判断、
9. 文件包含漏洞：开发在写代码时选择包含的文件可以由用户参数指include $_GET['page']
10. windows命令执行漏洞：管道符|，判断回显ping dnslog
11. HTML模板：相似框架的**html**页面使用**模板**，**php**代码则负责**替换参数**，美好的页面
12. **HTML模板->命令执行漏洞**：php文件会调用模板执行，在html模板文件中插入恶意php脚本
13. 安全的第三方html模板：Smarty ，也有nday
14. PHP安全：
    1. 代码本身漏洞
    2. 插件：ueditor
    3. 模板：Smarty 
    4. 组件 ：shiro、 fastjson
    5. 框架：thinkphp(存在内置过滤比如SQL)
15. 代码审计需要：熟悉框架
16. 框架漏洞：
    1. 框架本身漏洞
    2. 不使用框架推荐的安全写法，原生写法

### 二、JS

1. 过滤代码写在前端，可绕过
2. 修改**返回包**导致的**漏洞**，实际上是：**关键操作**放在前端**JS上执行**，而不是在后端代码
3. DOM-XSS：用户输入可控DOM导致的
4. JS对数据加密的原因：
   1. 防止批量跑PAYLOAD
   2. 防止暴力破解

**NodeJs:** js服务端运行环境

	在服务端运行的JS，前端看不见源码，只能看见执行结果

**RCE：**远程命令执行

1. 调用系统命令：exec('clac') 弹计算器

2. 代码执行：eval函数字符串执行

**WebPack：**

1. 作用：将多个js文件打包成一个
2. 模式与**源码泄露**：使用**开发者模式打包**导致NODEJS源码泄露，应该使用生产者模式
3. **PackerFuzzer**
   1. 搜索WebPack所生成的JS文件去找：未授权、信息泄露...
   2. 但是findsomething，只针对网页搜索，

**JQuery库漏洞**

### 三、JAVA EE

![在这里插入图片描述](E:\typora\img\b6172477795d41378b74580781806c4a.png)


1. 数据库驱动：JDBC、Mybatis
2. java**预编译**防止sql注入：输入照成语句逻辑改变就会识别
3. **Filter**过滤：访问触发
   1. 过滤payload
   2. 根据cookie过滤未授权
4. **内存马**：存在Listener、Filter中，后门存在与Serviet中，在目录中扫不到内存马
5. **Listener**：动作触发，比如创建/销毁cookie/session
6. 红队植入内存马，蓝队应急内存马
7. **内存马与JAVA**，内存马是要调出来的
8. **反射机制**：运行时执行，可以获取第三方库的类、对象、构造方法、成员方法，并获取/修改指，执行。

**反序列化**：

	序列化=对象->字节流/json数据...，反序列化就是反过来。目的是为了传输对象数据更加方便高效
	
	JAVA中的反序列化方法：
	
	1. 内置的readObject()、XMLDecoder()
	1. XStream、SnakeYaml、FastJson、Jackson

**反序列化漏洞**：

	当反序列化的对象继承关系中存在反序列化方法的**重写方法**或者对象存在其他隐函数等自动触发执行的函数，这些方法会在对象反序列化的时候执行，造成RCE漏洞

**JAVA 组件安全：**

1. log4j：处理日志输入输出的组件
   1. 漏洞成因：log.err导致命令执行
2. fastjson：处理json、对象数据、XLM数据格式转换的组件
   1. 漏洞成因：type对象类型转换，json数据->对象反序列化漏洞

**JNDI：**

![在这里插入图片描述](E:\typora\img\7463ba5b049e4dc5a9741356e6426d0d.png)




JNDI：JAVA命名和目录**接口**

	JNDI接口作用：实现**远程执行class**文件，使用**lookup方法**
	
	常见协议：LDAP(文件目录协议）、RMI（注册表协议）
	
	注入：思路就是利用这个接口的功能和这两个协议，让服务端远程执行我们编写的class文件达到命令执行
	
	限制：

![在这里插入图片描述](E:\typora\img\5225e336427a42009aa573477d3ea938.png)


jdk版本支持远程命令执行协议情况

	注入工具：只针对原生jndi注入的绕过
	
	1. Injection：不存在绕过
	1. marshalsec：rmi不能绕过、ldap可以绕过版本限制

**JNDI与反序列化结合案例：**

	fastjson存在反序列化漏洞，通过更改json的对象type类型能够实现执行其他对象的方法。那么只需要把这个类设置为可以调用jndi的lookup方法的类就行

**SpringBoot框架:**

	1. mybatis三种情况容易造成sql注入
	1. thymeleaf模板注入，在使用新的参数加载模板，参数可执行payload
法。那么只需要把这个类设置为可以调用jndi的lookup方法的类就行

**SpringBoot框架:**

	1. mybatis三种情况容易造成sql注入
	1. thymeleaf模板注入，在使用新的参数加载模板，参数可执行payload